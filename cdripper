#!/usr/bin/env python
import getopt, os, sys, threading, time, CDDB, DiscID

#TODO:
# Python bindings for lame
# Python bindings for cdparanoia
# Fetch CD Cover art
# change errors to exceptions

class album:
	def __init__(self):
		self.artist = None
		self.artist_dir = None
		self.album = None
		self.album_dir = None
		self.track_title = []
		self.track_name = []
		self.year = None
		self.genre = None
		self.device = "/dev/cdrom"
		self.dest_dir = os.environ['HOME']
		self.cleanup = True


	def _artist_name_fixup(self, artist):
		#for output uniformity, we should make sure that all titles that end with ", The" have "The " added to the beginning
		if artist.endswith(', The'):
			artist = artist.strip(', The')
			artist = "%s%s" %('The ', artist)

		if artist.endswith(', the'):
			artist = artist.strip(', the')
			artist = "%s%s" %('The ', artist)

		#Look for a similarly named artist already existing and change to that if so
		lower = artist.lower()
		lower = lower.replace(' ', '_')
		for files in os.listdir(self.dest_dir):
			if lower == files.lower():
				files = files.replace('_', ' ')
				print "Similar Artist %s found" %files
				artist = files

		self.artist = artist


	#This function adds a dep for CDDB-py
	def fetch_cddb(self):
		print "fetching"

		disc_id = DiscID.disc_id(DiscID.open(self.device, 0))

		(query_status, query_info) = CDDB.query(disc_id)
		if query_status != 200 and query_status != 210 and query_status != 211:
			print "Error encountered querying CDDB, error = %d" %query_status
			return True 

		if query_status == 210 or query_status == 211:
			print "Multiple Disc's found"
			for i in range(len(query_info)):
				temp_info = query_info[i]
				print "%d - Title = %s, Category %s, disc_id %s" %(i, temp_info['title'], temp_info['category'], temp_info['disc_id'])
			print "Please select the correct disc number"
			choice = input()
			while  choice < 0 or choice > i:
				print "Selection %d invalid, please choose again" %choice
				choice = input()

			print "Selection %d Chosen" %choice
			query_info = query_info[choice]

		(read_status, read_info) = CDDB.read(query_info['category'], query_info['disc_id'])
		if read_status != 210:
			print "Error encountered reading CDDB, error = %d" %read_status
			return True

		s = read_info['DTITLE']
		self.artist = s.split(' / ')[0]
		self.album = s.split(' / ')[1]

		self._artist_name_fixup(self.artist)

		self.artist_dir = self.artist.replace(' ', '_')
		self.album_dir = self.album.replace(' ', '_')

		self.year = read_info['DYEAR']
		self.genre = read_info['DGENRE']

		print self.artist
		print self.album
		print self.year
		print self.genre
		for i in range(disc_id[1]):
			self.track_title.append(read_info['TTITLE' + `i`])
			track_name = "%s - %.02d %s" %(self.artist, i+1, self.track_title[i])
			track_name = track_name.replace(' ', '_')
			self.track_name.append(track_name)
			print "%.02d - %s" %(i, self.track_title[i])

		return False


	#This function adds a dep for lame
	def _lame_thread(self, num):
		print "encoding track %d" %(num+1)

		lame_opts = "-S --preset extreme -q 0 -V 0"

		error = os.system('lame %s "%s.wav" "%s.mp3" --tt "%s" --ta "%s" --tl "%s" --ty "%s" --tn "%s" --tg "%s"'
				  %(lame_opts, self.track_name[num], self.track_name[num], self.track_title[num], self.artist, self.album, self.year, num+1, self.genre))
		if error:
			print "Error %d encounterd while encoding" %error
			return

		if self.cleanup:
			os.system('rm "%s.wav"' %self.track_name[num])
		print "done encoding track %d" %(num+1)


	#This function adds a dep for cdparanoia
	def _rip(self, num):
		error = os.system('cdparanoia -wd %s %d "%s.wav"' %(self.device, num, self.track_name[num]))
		if error:
			return -1

		return 0


	def rip_encode(self):
		print "ripping & encoding"

		for i in range(len(self.track_name)):
			error = self._rip(i)
			if error:
				return -1

			lt = threading.Thread(target=self._lame_thread, args=(i,))
			lt.start()

		return 0


	def create_dest_dir(self):
		print "creating dir"

		error = os.chdir(self.dest_dir)
		if error:
			return -1

		error = os.access(self.artist_dir, os.F_OK)
		if error == False:
			error = os.mkdir(self.artist_dir)
			if error:
				return -1

		error = os.chdir(self.artist_dir)
		if error:
			return -1

		error = os.access(self.album_dir, os.F_OK)
		if error == False:
			error = os.mkdir(self.album_dir)
			if error:
				return -1

		error = os.chdir(self.album_dir)
		if error:
			return -1

		return 0


	def create_playlist(self):
		print "creating playlist"

		error = os.chdir(self.dest_dir)
		if error:
			return -1

		m3u = open('%s_-_%s.m3u' %(self.artist_dir, self.album_dir), "w")

		for i in range(len(self.track_name)):
			s = "%s/%s/%s\n" %(self.artist_dir, self.album_dir, self.track_name[i])
			m3u.writelines(s)

		m3u.close()

		return 0


def main():
	disc = album()

	try:
		opts, args = getopt.getopt(sys.argv[1:], "", ["device=", "dest_dir=", "nocleanup"])
	except getopt.error, err:
		print str(err)
		sys.exit(2)

	for o, a in opts:
		if o == "--device":
			disc.device = a
		if o == "--dest_dir":
			disc.dest_dir = a
		if o == "--nocleanup":
			disc.cleanup = False	

	rc = disc.fetch_cddb()
	if rc:
		return

	rc = disc.create_playlist()
	if rc:
		return

	rc = disc.create_dest_dir()
	if rc:
		return

	rc = disc.rip_encode()
	if rc:
		return

	os.system('eject "%s"' %disc.device)


if __name__ == "__main__":
	main()
